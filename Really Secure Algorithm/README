Title:
Really Secure Algorithm
Description:
n:  25322068927450103683729820607218897472984612532240658503858773892715302243719311277309968051141205254379269402038253753262613594409374978610072048556890630404683193063107337041595857346652979099942701809150055854186814272762426743621636157089866212464832008260124158149687635448790051071743603146602718730198202200360361676904748855818911628670661790227531572255292762581206058066062620199852570260373777051263393621301100118900566351159218510106530803135440093593185789830146094074475630190717019650295630861815228048819383696159226069665196502726518238314761617197607854130103541005592795621068026090149276002784137
e:  3
c:  805020127242334055366101084106338318159380669025487944854096749019147092114876319062655375415404940686630370890131538091828517962791705559182147980190064106743981439257891695108968769958854184833599694692936244497276134034683391658524568253432985263893894205482860611555841067637424217249812301434007342625125


W tym zadaniu dostajemy wyłącznie trzy liczby: n, e oraz c. Nazwy te oraz nazwa zadania mówi nam, że mamy doczynienia z szyfrowaniem RSA. W dużym skrócie działa ono tak: jeśli m to wiadomość, e i n to klucz publiczny oraz d i n to klucz prywatny to szyfrogram c=(m^e)%n, a m=(c^d)%n. Problem mamy, gdy m i e jest małe, a n stosunkowo duże. Wtedy m^e jest mniejsze od n, a operacja c=(m^e)%n skraca się do c=m^e. Oznacza to, że znając e(a przecież e to część klucza publicznego!) można bez problemu obliczyć m, czyli oryginalną wiadomość, obliczając pierwiastek e-stopnia z c. W tym zadaniu widać, że c jest o wiele rzędów wielkości mniejsze od n, co jest bardzo mało prawdopodobne, jeśli operacja modulo n odbyła się podczas szyfrowania. Daje nam to wskazówkę, że wspomniany wcześniej problem jest tu obecny. Aby zdobyć flagę wystarczy więc wziąć pierwiastek trzeciego stopnia z c, a następnie skonwertować uzyskaną liczbę do tablicy bajtów.

Rozwiązanie jest w pliku solve.py
